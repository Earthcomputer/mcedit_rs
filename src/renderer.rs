use std::sync::Arc;
use std::sync::atomic::Ordering;
use ahash::AHashMap;
use approx::AbsDiffEq;
use glam::{Affine2, Affine3A, IVec3, IVec4, Mat4, Quat, Vec2, Vec3, Vec3Swizzles, Vec4};
use glium::{Frame, Surface, uniform};
use num_traits::FloatConst;
use crate::{blocks, CommonFNames, geom, make_a_hash_map, util};
use crate::geom::{BlockPos, ChunkPos, DVec3Extensions, IVec3Extensions, IVec3RangeExtensions, IVec2RangeExtensions};
use crate::resources::{Resources, TextureAtlas};
use crate::util::{BlitVertex, Lerp};
use crate::world::{Chunk, Dimension, IBlockState, World, WorldRef};
use crate::add_queued_task;

const MAIN_VERT_SHADER: &str = include_str!("../res/main.vsh");
const MAIN_FRAG_SHADER: &str = include_str!("../res/main.fsh");
const BLIT_VERT_SHADER: &str = include_str!("../res/blit.vsh");
const BLIT_FRAG_SHADER: &str = include_str!("../res/blit.fsh");

struct DisplayHolder {
    display: *const glium::Display,
    #[cfg(debug_assertions)]
    thread: std::thread::ThreadId,
}

static mut DISPLAY: Option<DisplayHolder> = None;

pub unsafe fn set_display(display: &glium::Display) {
    DISPLAY = Some(DisplayHolder {
        display,
        #[cfg(debug_assertions)]
        thread: std::thread::current().id(),
    });
}

pub unsafe fn clear_display() {
    DISPLAY = None;
}

pub fn get_display() -> &'static glium::Display {
    unsafe {
        let holder = DISPLAY.as_ref().unwrap();
        #[cfg(debug_assertions)]
        assert_eq!(holder.thread, std::thread::current().id());
        &*holder.display
    }
}

#[derive(Default)]
struct Geometry {
    vertices: Vec<util::Vertex>,
    indices: Vec<u32>,
}

#[derive(Default)]
struct ChunkGeometry {
    opaque_geometry: Geometry,
    transparent_geometry: Geometry,
    translucent_geometry: Geometry,
}

struct BakedGeometry {
    vertices: glium::VertexBuffer<util::Vertex>,
    indices: glium::IndexBuffer<u32>,
}

pub struct BakedChunkGeometry {
    opaque_geometry: BakedGeometry,
    transparent_geometry: BakedGeometry,
    translucent_geometry: BakedGeometry,
}

pub struct WorldRenderer {
    shader_program: glium::Program,
    transparent_shader_program: glium::Program,
    blit_shader_program: glium::Program,
    block_atlas_texture: glium::texture::SrgbTexture2d,
}

unsafe impl Send for WorldRenderer {}
unsafe impl Sync for WorldRenderer {}

const UNLOADED_RENDER_DISTANCE: i32 = 32;
const EXISTING_CHUNK_COLOR_A: [f32; 3] = [1.0, 0.5, 0.0];
const EXISTING_CHUNK_COLOR_B: [f32; 3] = [1.0, 1.0, 0.0];

thread_local! {
    static DEFAULT_DRAW_PARAMS: glium::DrawParameters<'static> = glium::DrawParameters {
        depth: glium::Depth {
            test: glium::DepthTest::IfLess,
            write: true,
            ..Default::default()
        },
        backface_culling: glium::draw_parameters::BackfaceCullingMode::CullClockwise,
        ..Default::default()
    };
}

impl WorldRenderer {
    pub fn new(_mc_version: &str, resources: &Resources) -> WorldRenderer {
        let atlas_image = glium::texture::RawImage2d::from_raw_rgba(
            resources.block_atlas.data.clone(),
            (resources.block_atlas.width, resources.block_atlas.height),
        );
        let (version_str, rest) = MAIN_FRAG_SHADER.split_at(MAIN_FRAG_SHADER.find('\n').unwrap());
        WorldRenderer {
            shader_program: glium::Program::from_source(get_display(), MAIN_VERT_SHADER, MAIN_FRAG_SHADER, None).unwrap(),
            transparent_shader_program: glium::Program::from_source(get_display(), MAIN_VERT_SHADER, format!("{}\n#define TRANSPARENCY\n{}", version_str, rest).as_str(), None).unwrap(),
            blit_shader_program: glium::Program::from_source(get_display(), BLIT_VERT_SHADER, BLIT_FRAG_SHADER, None).unwrap(),
            block_atlas_texture: glium::texture::SrgbTexture2d::with_mipmaps(get_display(), atlas_image, glium::texture::MipmapsOption::AutoGeneratedMipmapsMax(resources.mipmap_levels)).unwrap(),
        }
    }

    pub fn start_build_worker(world_ref: &WorldRef) {
        unsafe {
            world_ref.spawn_worker(|world, stop| {
                while !stop() {
                    let (dimension, pos) = {
                        let camera = world.camera.read().unwrap();
                        (camera.dimension.clone(), camera.pos)
                    };
                    let dimension = match world.get_dimension(&dimension) {
                        Some(d) => d,
                        None => {
                            World::worker_yield();
                            continue;
                        }
                    };
                    let camera_subchunk: IVec3 = pos.floor().as_ivec3() >> 4;
                    let render_distance_chunks = 16;
                    for subchunk_pos in ((camera_subchunk - glam::IVec3::ONE * render_distance_chunks)..=(camera_subchunk + glam::IVec3::ONE * render_distance_chunks)).iter() {
                        if subchunk_pos.y < (&dimension.min_y >> 4) || subchunk_pos.y > (&dimension.max_y >> 4) {
                            continue;
                        }
                        if let Some(chunk) = dimension.get_chunk(subchunk_pos.xz()) {
                            let subchunk_index = (subchunk_pos.y - (&dimension.min_y >> 4)) as usize;
                            if let Some(subchunk) = &chunk.subchunks[subchunk_index] {
                                if subchunk.needs_redraw.swap(false, Ordering::Acquire) {
                                    if stop() {
                                        break;
                                    }
                                    WorldRenderer::render_subchunk(world, &*dimension, chunk.clone(), subchunk_index, subchunk_pos);
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    pub fn has_changed(&self) -> bool {
        true
    }

    pub fn render_world(&self, world: &World, target: &mut glium::Frame) {
        let (dimension, pos, yaw, pitch) = {
            let camera = world.camera.read().unwrap();
            (camera.dimension.clone(), camera.pos, camera.yaw, camera.pitch)
        };
        let dimension_arc = match world.get_dimension(&dimension) {
            Some(d) => d,
            None => return,
        };
        let dimension = &*dimension_arc;

        let fov = 70.0f32;
        let render_distance_chunks = 16;
        let aspect_ratio = target.get_dimensions().0 as f32 / target.get_dimensions().1 as f32;
        let znear = 0.05f32;
        let zfar = render_distance_chunks as f32 * 64.0;
        let projection = Mat4::perspective_rh(fov.to_radians(), aspect_ratio, znear, zfar);
        let camera_pos = pos.to_float();
        let camera_yaw = yaw.to_radians();
        let camera_pitch = pitch.to_radians();
        let view_matrix = Mat4::from_rotation_x(-camera_pitch) * Mat4::from_rotation_y(-camera_yaw) * Mat4::from_translation(-camera_pos);
        let uniforms = uniform! {
                    projection_matrix: projection.to_cols_array_2d(),
                    view_matrix: view_matrix.to_cols_array_2d(),
                    tex: self.block_atlas_texture
                        .sampled()
                        .magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                        .minify_filter(glium::uniforms::MinifySamplerFilter::NearestMipmapLinear),
                    ambient_light: 0.1f32,
                    sky_brightness: 0.0f32,
                    sky_darkness: 0.0f32,
                    night_vision_strength: 0.0f32,
                    gamma: 1.0f32,
                };

        fn get_forward_vector(yaw: f32, pitch: f32) -> glam::DVec3 {
            let pitch = pitch.to_radians();
            let yaw = yaw.to_radians();
            let x = -(pitch.cos() * yaw.sin());
            let y = pitch.sin();
            let z = -(pitch.cos() * yaw.cos());
            glam::DVec3::new(x as f64, y as f64, z as f64)
        }
        let camera_pos = pos;
        let left_normal = get_forward_vector(yaw - 90.0f32 + fov, pitch);
        let right_normal = get_forward_vector(yaw + 90.0f32 - fov, pitch);
        let up_normal = get_forward_vector(yaw, pitch - 90.0f32 + fov);
        let down_normal = get_forward_vector(yaw, pitch + 90.0f32 - fov);
        let min_left_dot = left_normal.dot(camera_pos);
        let min_right_dot = right_normal.dot(camera_pos);
        let min_up_dot = up_normal.dot(camera_pos);
        let min_down_dot = down_normal.dot(camera_pos);
        let current_subchunk: IVec3 = camera_pos.floor().as_ivec3() >> 4;

        self.render_existing_chunks(world, &*dimension, target, &uniforms, current_subchunk);

        let mut subchunks_to_render = Vec::new();

        'subchunk_loop:
        for subchunk_pos in ((current_subchunk - glam::IVec3::ONE * render_distance_chunks)..=(current_subchunk + glam::IVec3::ONE * render_distance_chunks)).iter() {
            let subchunk_index = subchunk_pos.y - (dimension.min_y >> 4);
            if subchunk_index < 0 {
                continue;
            }
            let subchunk_index = subchunk_index as usize;

            for delta in (glam::IVec3::ZERO..=glam::IVec3::ONE).iter() {
                let pos = ((subchunk_pos + delta) * 16).as_dvec3();
                if left_normal.dot(pos) >= min_left_dot && right_normal.dot(pos) >= min_right_dot && up_normal.dot(pos) >= min_up_dot && down_normal.dot(pos) >= min_down_dot {
                    if let Some(achunk) = dimension.get_chunk(subchunk_pos.xz()) {
                        let chunk = achunk.as_ref();
                        if subchunk_index >= chunk.subchunks.len() {
                            continue 'subchunk_loop;
                        }
                        if chunk.subchunks[subchunk_index].is_some() {
                            subchunks_to_render.push((achunk.clone(), subchunk_index));
                        }
                    }
                    break;
                }
            }
        }

        for (chunk, index) in &subchunks_to_render {
            let subchunk = chunk.subchunks[*index].as_ref().unwrap();
            let subchunk_ref = subchunk.baked_geometry.lock().unwrap();
            if let Some(baked_subchunk) = subchunk_ref.as_ref() {
                DEFAULT_DRAW_PARAMS.with(|params| {
                    target.draw(
                        &baked_subchunk.opaque_geometry.vertices,
                        &baked_subchunk.opaque_geometry.indices,
                        &self.shader_program,
                        &uniforms,
                        params,
                    ).unwrap();
                });
            }
        }
        for (chunk, index) in &subchunks_to_render {
            let subchunk = chunk.subchunks[*index].as_ref().unwrap();
            let subchunk_ref = subchunk.baked_geometry.lock().unwrap();
            if let Some(baked_subchunk) = subchunk_ref.as_ref() {
                DEFAULT_DRAW_PARAMS.with(|params| {
                    target.draw(
                        &baked_subchunk.transparent_geometry.vertices,
                        &baked_subchunk.transparent_geometry.indices,
                        &self.transparent_shader_program,
                        &uniforms,
                        params,
                    ).unwrap();
                });
            }
        }

        let mut alpha_params = DEFAULT_DRAW_PARAMS.with(|params| params.clone());
        alpha_params.blend = glium::Blend::alpha_blending();

        for (chunk, index) in &subchunks_to_render {
            let subchunk = chunk.subchunks[*index].as_ref().unwrap();
            let subchunk_ref = subchunk.baked_geometry.lock().unwrap();
            if let Some(baked_subchunk) = subchunk_ref.as_ref() {
                // TODO: sort
                target.draw(
                    &baked_subchunk.translucent_geometry.vertices,
                    &baked_subchunk.translucent_geometry.indices,
                    &self.shader_program,
                    &uniforms,
                    &alpha_params
                ).unwrap();
            }
        }
    }

    fn render_existing_chunks<U>(&self, world: &World, dimension: &Dimension, target: &mut Frame, uniforms: &U, current_subchunk: IVec3)
    where
        U: glium::uniforms::Uniforms,
    {
        let mut existing_chunks_vertices = Vec::new();
        let mut existing_chunks_indices = Vec::new();
        for chunk_pos in ((current_subchunk.xz() - ChunkPos::new(UNLOADED_RENDER_DISTANCE, UNLOADED_RENDER_DISTANCE))..(current_subchunk.xz() + ChunkPos::new(UNLOADED_RENDER_DISTANCE, UNLOADED_RENDER_DISTANCE))).iter() {
            if dimension.does_chunk_exist(world, chunk_pos) {
                let color = if ((chunk_pos.x ^ chunk_pos.y) & 1) == 0 { EXISTING_CHUNK_COLOR_A } else { EXISTING_CHUNK_COLOR_B };
                fn world_pos(dimension: &Dimension, chunk_pos: ChunkPos) -> [f32; 3] {
                    [(chunk_pos.x << 4) as f32, dimension.min_y as f32, (chunk_pos.y << 4) as f32]
                }
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(dimension, chunk_pos),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(dimension, chunk_pos + ChunkPos::new(0, 1)),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(dimension, chunk_pos + ChunkPos::new(1, 1)),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(dimension, chunk_pos + ChunkPos::new(1, 0)),
                    color,
                });
                let index = (existing_chunks_vertices.len() - 4) as u32;
                existing_chunks_indices.push(index);
                existing_chunks_indices.push(index + 1);
                existing_chunks_indices.push(index + 2);
                existing_chunks_indices.push(index + 2);
                existing_chunks_indices.push(index + 3);
                existing_chunks_indices.push(index);
            }
        }
        let existing_chunks_vertices = glium::VertexBuffer::new(get_display(), &existing_chunks_vertices).unwrap();
        let existing_chunks_indices = glium::IndexBuffer::new(get_display(), glium::index::PrimitiveType::TrianglesList, &existing_chunks_indices).unwrap();
        DEFAULT_DRAW_PARAMS.with(|params| {
            target.draw(
                &existing_chunks_vertices,
                &existing_chunks_indices,
                &self.blit_shader_program,
                uniforms,
                params
            ).unwrap();
        });
    }

    fn render_subchunk(world: &World, dimension: &Dimension, chunk: Arc<Chunk>, subchunk_index: usize, subchunk_pos: BlockPos) {
        let subchunk = chunk.subchunks[subchunk_index].as_ref().unwrap();
        let mut chunk_geom = ChunkGeometry::default();
        for pos in (BlockPos::new(0, 0, 0)..BlockPos::new(16, 16, 16)).iter() {
            let block_state = subchunk.get_block_state(pos);
            WorldRenderer::render_state(world, dimension, &block_state, subchunk_pos * 16 + pos, &mut chunk_geom);
        }

        add_queued_task(move || {
            let subchunk = match chunk.subchunks[subchunk_index].as_ref() {
                Some(subchunk) => subchunk,
                None => return,
            };
            // upload to gpu
            let baked_geometry = BakedChunkGeometry {
                opaque_geometry: BakedGeometry {
                    vertices: glium::VertexBuffer::new(get_display(), &chunk_geom.opaque_geometry.vertices).unwrap(),
                    indices: glium::IndexBuffer::new(get_display(), glium::index::PrimitiveType::TrianglesList, &chunk_geom.opaque_geometry.indices).unwrap(),
                },
                transparent_geometry: BakedGeometry {
                    vertices: glium::VertexBuffer::new(get_display(), &chunk_geom.transparent_geometry.vertices).unwrap(),
                    indices: glium::IndexBuffer::new(get_display(), glium::index::PrimitiveType::TrianglesList, &chunk_geom.transparent_geometry.indices).unwrap(),
                },
                translucent_geometry: BakedGeometry {
                    vertices: glium::VertexBuffer::new(get_display(), &chunk_geom.translucent_geometry.vertices).unwrap(),
                    indices: glium::IndexBuffer::new(get_display(), glium::index::PrimitiveType::TrianglesList, &chunk_geom.translucent_geometry.indices).unwrap(),
                },
            };
            let mut dest_baked_geometry = subchunk.baked_geometry.lock().unwrap();
            *dest_baked_geometry = Some(baked_geometry);
        });
    }

    fn render_state(world: &World, dimension: &Dimension, state: &IBlockState, pos: BlockPos, out_geometry: &mut ChunkGeometry) {
        let color = blocks::get_block_color(world, dimension, pos, state);
        let baked_model = WorldRenderer::get_baked_model(world, state);
        for (dir, face) in &baked_model.faces {
            if let Some(dir) = dir {
                if let Some(neighbor) = dimension.get_block_state(pos + dir.forward()) {
                    let neighbor_model = WorldRenderer::get_baked_model(world, &neighbor);
                    if let Some(neighbor_face) = neighbor_model.faces.get(&Some(dir.opposite())) {
                        if (face.cull_mask[0] & !neighbor_face.cull_mask[0]) == IVec4::ZERO && (face.cull_mask[1] & !neighbor_face.cull_mask[1]) == IVec4::ZERO {
                            continue;
                        }
                    }
                }
            }
            let geom = match face.transparency {
                Transparency::Opaque => &mut out_geometry.opaque_geometry,
                Transparency::Transparent => &mut out_geometry.transparent_geometry,
                Transparency::Translucent => &mut out_geometry.translucent_geometry,
            };
            let index = geom.vertices.len() as u32;
            for vertex in &face.vertices {
                geom.vertices.push(util::Vertex {
                    position: [
                        vertex.position[0] + pos.x as f32,
                        vertex.position[1] + pos.y as f32,
                        vertex.position[2] + pos.z as f32,
                    ],
                    tex_coords: vertex.tex_coords,
                    lightmap_coords: [1.0, 0.0],
                    color: if vertex.tint { (color.as_vec3() / 255.0).to_array() } else { [1.0, 1.0, 1.0] },
                });
            }
            for i in &face.indices {
                geom.indices.push(index + *i as u32);
            }
        }
    }

    fn get_baked_model<'a>(world: &'a World, state: &IBlockState) -> &'a BakedModel {
        match world.resources.baked_model_cache.get(state) {
            Some(model) => model.value(),
            None => {
                world.resources.baked_model_cache.insert(state.clone(), WorldRenderer::bake_model(world, state));
                world.resources.baked_model_cache.get(state).unwrap().value()
            }
        }
    }

    fn bake_model(world: &World, state: &IBlockState) -> BakedModel {
        let atlas = &world.resources.block_atlas;
        let models = match world.resources.get_block_model(state) {
            Some(models) => models,
            None => return WorldRenderer::bake_missingno(atlas)
        };

        let mut baked_model = BakedModel {
            ambient_occlusion: true,
            ..Default::default()
        };

        for model in models {
            let model_transform = Mat4::from_translation(Vec3::new(0.5, 0.5, 0.5))
                * match model.x_rotation.rem_euclid(360) {
                    90 => Mat4::from_cols(Vec4::X, Vec4::Z, -Vec4::Y, Vec4::W),
                    180 => Mat4::from_cols(Vec4::X, -Vec4::Y, -Vec4::Z, Vec4::W),
                    270 => Mat4::from_cols(Vec4::X, -Vec4::Z, Vec4::Y, Vec4::W),
                    _ => Mat4::IDENTITY,
                }
                * match model.y_rotation.rem_euclid(360) {
                    90 => Mat4::from_cols(Vec4::Z, Vec4::Y, -Vec4::X, Vec4::W),
                    180 => Mat4::from_cols(-Vec4::X, Vec4::Y, -Vec4::Z, Vec4::W),
                    270 => Mat4::from_cols(-Vec4::Z, Vec4::Y, Vec4::X, Vec4::W),
                    _ => Mat4::IDENTITY,
                }
                * Mat4::from_translation(Vec3::new(-0.5, -0.5, -0.5))
                * (Mat4::from_scale(Vec3::ONE * 0.0625));
            let uvlock = model.uvlock;
            let model = model.model;
            baked_model.ambient_occlusion = baked_model.ambient_occlusion && model.ambient_occlusion;
            for element in &model.elements {
                let mut element_transform = match element.rotation.axis {
                    geom::Axis::X => Mat4::from_rotation_x(element.rotation.angle.to_radians()),
                    geom::Axis::Y => Mat4::from_rotation_y(element.rotation.angle.to_radians()),
                    geom::Axis::Z => Mat4::from_rotation_z(element.rotation.angle.to_radians()),
                };
                if element.rotation.rescale {
                    let scale = if element.rotation.angle.abs() == 22.5 {
                        f32::FRAC_PI_8().cos().recip()
                    } else {
                        f32::SQRT_2()
                    };
                    element_transform *= Mat4::from_scale(Vec3::new(scale, 1.0, scale));
                }
                element_transform = Mat4::from_translation(element.rotation.origin)
                    * element_transform
                    * Mat4::from_translation(-element.rotation.origin);
                element_transform = model_transform * element_transform;

                for (dir, face) in &element.faces {
                    // TODO: face.rotation
                    let (u1, v1, u2, v2) = if let Some(uv) = &face.uv {
                        (uv.u1, uv.v1, uv.u2, uv.v2)
                    } else {
                        match dir {
                            geom::Direction::PosX => (16.0 - element.to.z, 16.0 - element.to.y, 16.0 - element.from.z, 16.0 - element.from.y),
                            geom::Direction::NegX => (element.from.z, 16.0 - element.to.y, element.to.z, 16.0 - element.from.y),
                            geom::Direction::PosY => (element.from.x, element.from.z, element.to.x, element.to.z),
                            geom::Direction::NegY => (element.from.x, 16.0 - element.to.z, element.to.x, 16.0 - element.from.z),
                            geom::Direction::PosZ => (element.from.x, 16.0 - element.to.y, element.to.x, 16.0 - element.from.y),
                            geom::Direction::NegZ => (16.0 - element.to.x, 16.0 - element.to.y, 16.0 - element.from.x, 16.0 - element.from.y),
                        }
                    };
                    let (u1, v1, u2, v2) = if uvlock && dir.transform(&model_transform) == dir {
                        let uvlock_transform =
                            Mat4::from_translation(Vec3::new(0.5, 0.5, 0.5))
                                * Mat4::from_quat(Quat::from_rotation_arc(dir.forward().to_float(), Vec3::Y))
                                * Mat4::from_translation(Vec3::new(-0.5, -0.5, -0.5))
                                * model_transform
                                * Mat4::from_translation(Vec3::new(8.0, 8.0, 8.0))
                                * Mat4::from_quat(Quat::from_rotation_arc(Vec3::Y, dir.forward().to_float()))
                                * Mat4::from_translation(Vec3::new(-8.0, -8.0, -8.0));
                        let trans_uv = uvlock_transform.transform_point3(Vec3::new(u1, 0.0, v1));
                        let (trans_u1, trans_v1) = (trans_uv.x, trans_uv.z);
                        let trans_uv = model_transform.transform_point3(Vec3::new(u2, 0.0, v2));
                        let (trans_u2, trans_v2) = (trans_uv.x, trans_uv.z);
                        fn zero_safe_signum(n: f32) -> f32 {
                            // because rust is stupid
                            if n == 0.0 {
                                n
                            } else {
                                n.signum()
                            }
                        }
                        let (u1, u2) = if zero_safe_signum(u2 - u1) == zero_safe_signum(trans_u2 - trans_u1) {
                            (trans_u1, trans_u2)
                        } else {
                            (trans_u2, trans_u1)
                        };
                        let (v1, v2) = if zero_safe_signum(v2 - v1) == zero_safe_signum(trans_v2 - trans_v1) {
                            (trans_v1, trans_v2)
                        } else {
                            (trans_v2, trans_v1)
                        };
                        (u1, v1, u2, v2)
                    } else {
                        (u1 / 16.0, v1 / 16.0, u2 / 16.0, v2 / 16.0)
                    };
                    let sprite = match face.texture.strip_prefix('#')
                        .and_then(|texture| model.textures.get(texture))
                        .and_then(|texture| atlas.get_sprite(texture))
                    {
                        Some(sprite) => sprite,
                        None => return WorldRenderer::bake_missingno(atlas)
                    };
                    let (u1, v1, u2, v2) = ((sprite.u1 as f32).lerp(sprite.u2 as f32, u1), (sprite.v1 as f32).lerp(sprite.v2 as f32, v1), (sprite.u1 as f32).lerp(sprite.u2 as f32, u2), (sprite.v1 as f32).lerp(sprite.v2 as f32, v2));
                    let (u1, v1, u2, v2) = (u1 / atlas.width as f32, v1 / atlas.height as f32, u2 / atlas.width as f32, v2 / atlas.height as f32);
                    let dest_face = dir.transform(&element_transform);
                    let mut dest_face = if dest_face.forward().as_vec3().abs_diff_eq(element_transform.transform_vector3(dir.forward().as_vec3()).normalize(), 0.001) {
                        Some(dest_face)
                    } else {
                        None
                    };
                    let (vert1, vert2, vert3, vert4) = match dir {
                        geom::Direction::PosX =>
                            (Vec3::new(element.to.x, element.from.y, element.to.z), Vec3::new(element.to.x, element.from.y, element.from.z),
                             Vec3::new(element.to.x, element.to.y, element.from.z), Vec3::new(element.to.x, element.to.y, element.to.z)),
                        geom::Direction::NegX =>
                            (Vec3::new(element.from.x, element.from.y, element.from.z), Vec3::new(element.from.x, element.from.y, element.to.z),
                             Vec3::new(element.from.x, element.to.y, element.to.z), Vec3::new(element.from.x, element.to.y, element.from.z)),
                        geom::Direction::PosY =>
                            (Vec3::new(element.from.x, element.to.y, element.to.z), Vec3::new(element.to.x, element.to.y, element.to.z),
                             Vec3::new(element.to.x, element.to.y, element.from.z), Vec3::new(element.from.x, element.to.y, element.from.z)),
                        geom::Direction::NegY =>
                            (Vec3::new(element.from.x, element.from.y, element.from.z), Vec3::new(element.to.x, element.from.y, element.from.z),
                             Vec3::new(element.to.x, element.from.y, element.to.z), Vec3::new(element.from.x, element.from.y, element.to.z)),
                        geom::Direction::PosZ =>
                            (Vec3::new(element.from.x, element.from.y, element.to.z), Vec3::new(element.to.x, element.from.y, element.to.z),
                             Vec3::new(element.to.x, element.to.y, element.to.z), Vec3::new(element.from.x, element.to.y, element.to.z)),
                        geom::Direction::NegZ =>
                            (Vec3::new(element.to.x, element.from.y, element.from.z), Vec3::new(element.from.x, element.from.y, element.from.z),
                             Vec3::new(element.from.x, element.to.y, element.from.z), Vec3::new(element.to.x, element.to.y, element.from.z)),
                    };
                    if !dest_face.map(|dest_face| (vert1 * 0.125 - 1.0).dot(dest_face.forward().as_vec3()).abs_diff_eq(&1.0f32, 0.001)).unwrap_or(false) {
                        dest_face = None;
                    }
                    let cull_mask = if let Some(dest_face) = dest_face {
                        let transform = Affine3A::from_translation(Vec3::new(0.5, 0.5, 0.5))
                            * Affine3A::from_quat(Quat::from_rotation_arc(dest_face.forward().as_vec3(), Vec3::Z))
                            * Affine3A::from_translation(Vec3::new(-0.5, -0.5, -0.5))
                            * Affine3A::from_scale(Vec3::new(1.0 / 16.0, 1.0 / 16.0, 1.0 / 16.0));
                        let (vert1, vert2, vert4) = (transform.transform_point3(vert1).xy(), transform.transform_point3(vert2).xy(), transform.transform_point3(vert4).xy());
                        let face_transform = Affine2::from_cols(vert2 - vert1, vert4 - vert1, vert1);
                        let mut cull_mask = [IVec4::ZERO, IVec4::ZERO];
                        for x in 0..16 {
                            for y in 0..16 {
                                let transformed = face_transform.transform_point2(Vec2::new(x as f32 / 16.0, y as f32 / 16.0));
                                let (x, y) = (transformed.x, transformed.y);
                                let u = (sprite.u1 as f32).lerp(sprite.u2 as f32, x).round() as i32;
                                let v = (sprite.v1 as f32).lerp(sprite.v2 as f32, y).round() as i32;
                                let alpha = atlas.get_alpha(u.clamp(0, atlas.width as i32 - 1) as u32, v.clamp(0, atlas.height as i32 - 1) as u32);
                                if alpha == 255 {
                                    let mut x = ((x * 16.0).round() as i32).clamp(0, 15);
                                    let mut y = ((y * 16.0).round() as i32).clamp(0, 15);
                                    if dest_face.forward().dot(IVec3::ONE) == -1 {
                                        x = 15 - x;
                                        y = 15 - y;
                                    }
                                    cull_mask[(y >> 3) as usize][((y >> 1) & 3) as usize] |= 1 << (((y & 1) << 4) | x);
                                }
                            }
                        }
                        cull_mask
                    } else {
                        [IVec4::ZERO, IVec4::ZERO]
                    };
                    let dest_face = baked_model.faces.entry(dest_face).or_default();
                    let index = dest_face.vertices.len() as u16;
                    dest_face.vertices.push(BakedModelVertex {
                        position: element_transform.transform_point3(vert1).to_array(),
                        tex_coords: [u1, v2],
                        tint: face.tint_index != -1,
                    });
                    dest_face.vertices.push(BakedModelVertex {
                        position: element_transform.transform_point3(vert2).to_array(),
                        tex_coords: [u2, v2],
                        tint: face.tint_index != -1,
                    });
                    dest_face.vertices.push(BakedModelVertex {
                        position: element_transform.transform_point3(vert3).to_array(),
                        tex_coords: [u2, v1],
                        tint: face.tint_index != -1,
                    });
                    dest_face.vertices.push(BakedModelVertex {
                        position: element_transform.transform_point3(vert4).to_array(),
                        tex_coords: [u1, v1],
                        tint: face.tint_index != -1,
                    });
                    dest_face.indices.push(index);
                    dest_face.indices.push(index + 1);
                    dest_face.indices.push(index + 2);
                    dest_face.indices.push(index + 2);
                    dest_face.indices.push(index + 3);
                    dest_face.indices.push(index);
                    dest_face.transparency = dest_face.transparency.merge(sprite.transparency);
                    dest_face.cull_mask[0] = dest_face.cull_mask[0] | cull_mask[0];
                    dest_face.cull_mask[1] = dest_face.cull_mask[1] | cull_mask[1];
                }
            }
        }
        baked_model
    }

    fn bake_missingno(atlas: &TextureAtlas) -> BakedModel {
        let sprite = atlas.get_sprite(&CommonFNames.MISSINGNO).unwrap();
        let (u1, v1, u2, v2) = (
            sprite.u1 as f32 / atlas.width as f32,
            sprite.v1 as f32 / atlas.height as f32,
            sprite.u2 as f32 / atlas.width as f32,
            sprite.v2 as f32 / atlas.height as f32
        );
        let faces = make_a_hash_map!(
            Some(geom::Direction::NegZ) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [0.0, 0.0, 0.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 1.0, 0.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 0.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 0.0, 0.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
            Some(geom::Direction::PosZ) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [0.0, 0.0, 1.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 0.0, 1.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 1.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 1.0, 1.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
            Some(geom::Direction::NegX) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [1.0, 0.0, 0.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 0.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 1.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 0.0, 1.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
            Some(geom::Direction::PosX) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [0.0, 0.0, 1.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 1.0, 1.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 1.0, 0.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 0.0, 0.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
            Some(geom::Direction::NegY) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [0.0, 0.0, 0.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 0.0, 0.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 0.0, 1.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 0.0, 1.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
            Some(geom::Direction::PosY) => BakedModelFace {
                vertices: vec![
                    BakedModelVertex {
                        position: [0.0, 1.0, 1.0],
                        tex_coords: [u1, v1],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 1.0],
                        tex_coords: [u1, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [1.0, 1.0, 0.0],
                        tex_coords: [u2, v2],
                        tint: false,
                    },
                    BakedModelVertex {
                        position: [0.0, 1.0, 0.0],
                        tex_coords: [u2, v1],
                        tint: false,
                    },
                ],
                indices: vec![0, 1, 2, 2, 3, 0],
                transparency: Transparency::Opaque,
                cull_mask: [!IVec4::ZERO, !IVec4::ZERO],
            },
        );
        return BakedModel { faces, ambient_occlusion: false }
    }
}

#[derive(Default)]
pub struct BakedModel {
    faces: AHashMap<Option<geom::Direction>, BakedModelFace>,
    ambient_occlusion: bool,
}

#[derive(Default)]
struct BakedModelFace {
    vertices: Vec<BakedModelVertex>,
    indices: Vec<u16>,
    transparency: Transparency,
    // 256 bits of data, 1 if there is a pixel on the face touching this side
    cull_mask: [glam::IVec4; 2],
}

struct BakedModelVertex {
    position: [f32; 3],
    tex_coords: [f32; 2],
    tint: bool,
}

#[derive(Clone, Copy, Default)]
pub enum Transparency {
    #[default]
    Opaque,
    Translucent,
    Transparent,
}

impl Transparency {
    pub fn merge(self, other: Transparency) -> Transparency {
        match (self, other) {
            (Transparency::Translucent, _) => Transparency::Translucent,
            (_, Transparency::Translucent) => Transparency::Translucent,
            (Transparency::Transparent, _) => Transparency::Transparent,
            (_, Transparency::Transparent) => Transparency::Transparent,
            (Transparency::Opaque, Transparency::Opaque) => Transparency::Opaque,
        }
    }
}
