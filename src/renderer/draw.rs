use std::sync::Arc;
use std::sync::atomic::Ordering;
use approx::AbsDiffEq;
use glam::{DVec3, IVec2, IVec3, Mat4, Vec3Swizzles};
use glium::{Frame, Surface, uniform};
use num_traits::FloatConst;
use crate::fname::FName;
use crate::geom::{ChunkPos, IVec2Extensions, IVec2RangeExtensions, IVec3RangeExtensions};
use crate::{renderer, World};
use crate::renderer::storage::ChunkStore;
use crate::resources::Resources;
use crate::util::{BlitVertex, FastDashMap, MainThreadStore, make_fast_dash_map};
use crate::world::Dimension;

const MAIN_VERT_SHADER: &str = include_str!("../../res/main.vsh");
const MAIN_FRAG_SHADER: &str = include_str!("../../res/main.fsh");
const BLIT_VERT_SHADER: &str = include_str!("../../res/blit.vsh");
const BLIT_FRAG_SHADER: &str = include_str!("../../res/blit.fsh");

const EXISTING_CHUNK_COLOR_A: [f32; 3] = [1.0, 0.5, 0.0];
const EXISTING_CHUNK_COLOR_B: [f32; 3] = [1.0, 1.0, 0.0];

thread_local! {
    static DEFAULT_DRAW_PARAMS: glium::DrawParameters<'static> = glium::DrawParameters {
        depth: glium::Depth {
            test: glium::DepthTest::IfLess,
            write: true,
            ..Default::default()
        },
        backface_culling: glium::draw_parameters::BackfaceCullingMode::CullClockwise,
        ..Default::default()
    };
}

pub struct WorldRenderer {
    shader_program: MainThreadStore<glium::Program>,
    transparent_shader_program: MainThreadStore<glium::Program>,
    blit_shader_program: MainThreadStore<glium::Program>,
    block_atlas_texture: MainThreadStore<glium::texture::SrgbTexture2d>,
    pub(super) chunk_store: FastDashMap<FName, ChunkStore>,
}

impl WorldRenderer {
    pub fn new(_mc_version: &str, resources: Arc<Resources>) -> WorldRenderer {
        WorldRenderer {
            shader_program: MainThreadStore::create(|| glium::Program::from_source(renderer::get_display(), MAIN_VERT_SHADER, MAIN_FRAG_SHADER, None).unwrap()),
            transparent_shader_program: MainThreadStore::create(|| {
                let (version_str, rest) = MAIN_FRAG_SHADER.split_at(MAIN_FRAG_SHADER.find('\n').unwrap());
                let fragment_shader = format!("{}\n#define TRANSPARENCY\n{}", version_str, rest);
                glium::Program::from_source(renderer::get_display(), MAIN_VERT_SHADER, fragment_shader.as_str(), None).unwrap()
            }),
            blit_shader_program: MainThreadStore::create(|| glium::Program::from_source(renderer::get_display(), BLIT_VERT_SHADER, BLIT_FRAG_SHADER, None).unwrap()),
            block_atlas_texture: MainThreadStore::create(move || {
                let atlas_image = glium::texture::RawImage2d::from_raw_rgba(
                    resources.block_atlas.data.clone(),
                    (resources.block_atlas.width, resources.block_atlas.height),
                );
                glium::texture::SrgbTexture2d::with_mipmaps(renderer::get_display(), atlas_image, glium::texture::MipmapsOption::AutoGeneratedMipmapsMax(resources.mipmap_levels)).unwrap()
            }),
            chunk_store: make_fast_dash_map(),
        }
    }

        pub fn has_changed(&self) -> bool {
        true
    }

        pub fn render_world(&self, world: &World, target: &mut glium::Frame) {
        let (dimension, camera_pos, yaw, pitch) = {
            let camera = world.camera.read().unwrap();
            (camera.dimension.clone(), camera.pos, camera.yaw, camera.pitch)
        };
        let dimension_arc = match world.get_dimension(&dimension) {
            Some(d) => d,
            None => return,
        };

        let current_chunk: IVec2 = camera_pos.xz().floor().as_ivec2() >> 4i8;
        let render_distance_chunks = crate::get_config().render_distance();
        let chunk_store = self.chunk_store.entry(dimension).or_insert_with(|| {
            ChunkStore::new(render_distance_chunks, ((dimension_arc.max_y - dimension_arc.min_y + 1) >> 4) as u32)
        }).downgrade();
        let _camera_chunk_guard = chunk_store.set_camera_pos(current_chunk);

        let dimension = &*dimension_arc;

        let fov = 70.0f32.to_radians();
        let aspect_ratio = target.get_dimensions().0 as f32 / target.get_dimensions().1 as f32;
        let znear = 0.05f32;
        let zfar = render_distance_chunks.max(crate::get_config().unloaded_render_distance) as f32 * 64.0;
        let projection = Mat4::perspective_rh(fov, aspect_ratio, znear, zfar);
        let camera_yaw = yaw.to_radians();
        let camera_pitch = pitch.to_radians();
        let view_matrix = Mat4::from_rotation_x(-camera_pitch) * Mat4::from_rotation_y(-camera_yaw);
        let uniforms = |chunk_pos: ChunkPos| {
            uniform! {
                projection_matrix: projection.to_cols_array_2d(),
                view_matrix: (view_matrix * Mat4::from_translation((DVec3::new((chunk_pos.x << 4) as f64, 0.0, (chunk_pos.y << 4) as f64) - camera_pos).as_vec3())).to_cols_array_2d(),
                tex: self.block_atlas_texture
                    .sampled()
                    .magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                    .minify_filter(glium::uniforms::MinifySamplerFilter::NearestMipmapLinear),
                ambient_light: 0.1f32,
                sky_brightness: 0.0f32,
                sky_darkness: 0.0f32,
                night_vision_strength: 0.0f32,
                gamma: 1.0f32,
            }
        };

        self.render_existing_chunks(world, dimension, target, &uniforms(current_chunk), current_chunk);

        let mut chunks_to_render = Vec::new();

        for chunk_pos in current_chunk.square_range(render_distance_chunks as i32).iter() {
            if Self::frustum_check(dimension, chunk_pos, camera_pos, camera_yaw, camera_pitch, fov) {
                let built_chunk = chunk_store.get(chunk_pos);
                if built_chunk.ready.load(Ordering::Acquire) {
                    chunks_to_render.push((chunk_pos, built_chunk));
                }
            }
        }

        for (pos, chunk) in &chunks_to_render {
            DEFAULT_DRAW_PARAMS.with(|params| {
                (*chunk.baked_geometry).borrow().opaque_geometry.draw(
                    target, &self.shader_program, &uniforms(*pos), params
                );
            });
        }
        for (pos, chunk) in &chunks_to_render {
            DEFAULT_DRAW_PARAMS.with(|params| {
                (*chunk.baked_geometry).borrow().transparent_geometry.draw(
                    target, &self.transparent_shader_program, &uniforms(*pos), params
                );
            });
        }

        let mut alpha_params = DEFAULT_DRAW_PARAMS.with(|params| params.clone());
        alpha_params.blend = glium::Blend::alpha_blending();

        for (pos, chunk) in &chunks_to_render {
            (*chunk.baked_geometry).borrow().translucent_geometry.draw(
                target, &self.shader_program, &uniforms(*pos), &alpha_params
            );
        }
    }

    fn frustum_check(dimension: &Dimension, chunk_pos: ChunkPos, camera_pos: DVec3, yaw_radians: f32, pitch_radians: f32, fov_radians: f32) -> bool {
        fn get_forward_vector(yaw: f32, pitch: f32) -> glam::DVec3 {
            let x = -(pitch.cos() * yaw.sin());
            let y = pitch.sin();
            let z = -(pitch.cos() * yaw.cos());
            glam::DVec3::new(x as f64, y as f64, z as f64)
        }

        let left_forward = get_forward_vector(yaw_radians - fov_radians, pitch_radians);
        let right_forward = get_forward_vector(yaw_radians + fov_radians, pitch_radians);
        let up_forward = get_forward_vector(yaw_radians, pitch_radians + fov_radians);
        let down_forward = get_forward_vector(yaw_radians, pitch_radians - fov_radians);
        let left_normal = get_forward_vector(yaw_radians - f32::FRAC_PI_2() - fov_radians, pitch_radians);
        let right_normal = get_forward_vector(yaw_radians + f32::FRAC_PI_2() + fov_radians, pitch_radians);
        let up_normal = get_forward_vector(yaw_radians, pitch_radians + f32::FRAC_PI_2() + fov_radians);
        let down_normal = get_forward_vector(yaw_radians, pitch_radians - f32::FRAC_PI_2() - fov_radians);
        let forwards = [left_forward, right_forward, up_forward, down_forward];
        let normals = [left_normal, right_normal, up_normal, down_normal];

        let chunk_corners: Vec<_> = (IVec3::ZERO..=IVec3::ONE).iter().map(|delta| {
            (IVec3::new(chunk_pos.x << 4, dimension.min_y, chunk_pos.y << 4) + delta * IVec3::new(16, dimension.max_y - dimension.min_y + 1, 16)).as_dvec3()
        }).collect();

        let is_separating_axis = |axis: DVec3| {
            // handle frustum points at infinity
            let mut had_pos_inf = false;
            let mut had_neg_inf = false;
            for forward in &forwards {
                let dot = forward.dot(axis);
                if dot.abs_diff_eq(&0.0, 0.0001) {
                    // zero means it has the same dot product as the camera point, which is handled below
                } else if dot > 0.0 {
                    had_pos_inf = true;
                } else {
                    had_neg_inf = true;
                }
            }
            if had_pos_inf && had_neg_inf {
                // impossible that chunk cannot lie between positive and negative infinity
                return false;
            }

            // handle the finite point at the camera
            let camera_dot = camera_pos.dot(axis);
            let expected_less = chunk_corners[0].dot(axis) < camera_dot;
            if expected_less && had_neg_inf || !expected_less && had_pos_inf {
                return false;
            }

            for corner in chunk_corners.iter().skip(1) {
                if (corner.dot(axis) < camera_dot) != expected_less {
                    return false;
                }
            }

            true
        };

        for normal in &normals {
            if is_separating_axis(*normal) {
                return false;
            }
        }
        if is_separating_axis(DVec3::X) || is_separating_axis(DVec3::Y) || is_separating_axis(DVec3::Z) {
            return false;
        }

        for forward in &forwards {
            for chunk_axis in [DVec3::X, DVec3::Y, DVec3::Z] {
                let cross_product = forward.cross(chunk_axis);
                if cross_product.length_squared() > 0.0001 && is_separating_axis(cross_product) {
                    return false;
                }
            }
        }

        true
    }

    fn render_existing_chunks<U>(&self, world: &World, dimension: &Dimension, target: &mut Frame, uniforms: &U, current_chunk: IVec2)
        where
            U: glium::uniforms::Uniforms,
    {
        let mut existing_chunks_vertices = Vec::new();
        let mut existing_chunks_indices = Vec::new();
        for chunk_pos in current_chunk.square_range(crate::get_config().unloaded_render_distance() as i32).iter() {
            if dimension.try_does_chunk_exist(world, chunk_pos) == Some(true) {
                let color = if ((chunk_pos.x ^ chunk_pos.y) & 1) == 0 { EXISTING_CHUNK_COLOR_A } else { EXISTING_CHUNK_COLOR_B };
                let world_pos = |chunk_pos: ChunkPos| {
                    let chunk_pos = chunk_pos - current_chunk;
                    [(chunk_pos.x << 4) as f32, dimension.min_y as f32, (chunk_pos.y << 4) as f32]
                };
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(chunk_pos),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(chunk_pos + ChunkPos::new(0, 1)),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(chunk_pos + ChunkPos::new(1, 1)),
                    color,
                });
                existing_chunks_vertices.push(BlitVertex {
                    position: world_pos(chunk_pos + ChunkPos::new(1, 0)),
                    color,
                });
                let index = (existing_chunks_vertices.len() - 4) as u32;
                existing_chunks_indices.push(index);
                existing_chunks_indices.push(index + 1);
                existing_chunks_indices.push(index + 2);
                existing_chunks_indices.push(index + 2);
                existing_chunks_indices.push(index + 3);
                existing_chunks_indices.push(index);
            }
        }
        let existing_chunks_vertices = glium::VertexBuffer::new(renderer::get_display(), &existing_chunks_vertices).unwrap();
        let existing_chunks_indices = glium::IndexBuffer::new(renderer::get_display(), glium::index::PrimitiveType::TrianglesList, &existing_chunks_indices).unwrap();
        DEFAULT_DRAW_PARAMS.with(|params| {
            target.draw(
                &existing_chunks_vertices,
                &existing_chunks_indices,
                &self.blit_shader_program,
                uniforms,
                params
            ).unwrap();
        });
    }
}